<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Xunuo's Blog]]></title>
  <subtitle><![CDATA[许诺]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.xunuo.com//"/>
  <updated>2015-06-16T02:39:14.000Z</updated>
  <id>http://blog.xunuo.com//</id>
  
  <author>
    <name><![CDATA[xunuo]]></name>
    <email><![CDATA[i@xunuo.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[「译」- 使用Webpack更加智能的预编译CSS]]></title>
    <link href="http://blog.xunuo.com/smarter-css-builds-with-webpack/"/>
    <id>http://blog.xunuo.com/smarter-css-builds-with-webpack/</id>
    <published>2015-06-16T02:39:14.000Z</published>
    <updated>2015-06-16T02:39:14.000Z</updated>
    <content type="html"><![CDATA[<p>现在应该没人会把所有样式都写入一个超大的CSS里面了吧…</p>
<blockquote>
<p>原文：<a href="http://bensmithett.com/smarter-css-builds-with-webpack/" target="_blank" rel="external">Smarter CSS builds with Webpack</a></p>
</blockquote>
<a id="more"></a>
<hr>
<p>作为一个常常写CSS的开发人员，如果你接触过<a href="https://smacss.com/" target="_blank" rel="external">SMACSS</a>、<a href="https://suitcss.github.io/" target="_blank" rel="external">SUIT</a>或<a href="https://en.bem.info/method/definitions/" target="_blank" rel="external">BEM</a>的话，应该会自然而然的将文件拆成更小更分散的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stylesheets/&#10;  config/&#10;    colors.sass&#10;    media_queries.sass&#10;  modules/&#10;    btn.sass&#10;    dropdown.sass&#10;    header.sass&#10;  utilities/&#10;    align.sass&#10;    clearfix.sass</span><br></pre></td></tr></table></figure>
<p>当你需要将这些编译成单个文件(如<code>bundle.css</code>)供用户下载时，你不得不手工指定应用需要哪些文件。</p>
<p>在SASS中，<code>@import</code>也许是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &#34;vendor/normalize&#34;&#10;&#10;@import &#34;config/colors&#34;&#10;@import &#34;config/media_queries&#34;&#10;&#10;@import &#34;modules/btn&#34;&#10;@import &#34;modules/dropdown&#34;&#10;@import &#34;modules/header&#34;&#10;&#10;@import &#34;utilities/align&#34;&#10;@import &#34;utilities/clearfix&#34;</span><br></pre></td></tr></table></figure>
<p>如果你使用过 <a href="http://guides.rubyonrails.org/asset_pipeline.html" target="_blank" rel="external">Rail</a> 或 <a href="https://middlemanapp.com/" target="_blank" rel="external">Middleman</a>，你一定对 <a href="https://github.com/sstephenson/sprockets#managing-and-bundling-dependencies" target="_blank" rel="external">Sprockets</a> 的 <code>//= require</code> 语句不陌生:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//= require vendor/normalize&#10;//= require_tree ./modules&#10;//= require_tree ./utilities</span><br></pre></td></tr></table></figure>
<p>或者可能你有自己的一套流水线，使用<a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a>或<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>去收集、处理与合并这些单独的文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.src(<span class="string">'styles/**/*.scss'</span>)</span><br><span class="line">    .pipe(sass())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./tmp'</span>))</span><br><span class="line">    .pipe(concat(<span class="string">'bundle.css'</span>))</span><br><span class="line">    .pipe(autoprefixer())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所有的这些方式都有个前提，就是你需要知道哪些CSS是你的应用真正用到的，你不得不硬着头皮去维护一个无聊的依赖文件依赖表，或是干脆引入一整个目录。</p>
<p>这样一来，你很有可能引入一些冗余的CSS，而且只能寄托于在偶尔编写HTML模板时候根据标签里的class name来发现并清理它们。（当然这里有一些很棒的工具可以帮到你，如：<a href="http://addyosmani.com/blog/removing-unused-css/" target="_blank" rel="external">uncss</a>）</p>
<p>你需要在你的HTML头部去维护一份CSS依赖，在我看来，这是个无法忍受的事情。</p>
<p>不过不用担心，如果你使用Javascript模块来生成HTML，一切将迎刃而解（如果你还没这样做，不如趁早尝试这种来自未来的技术）。</p>
<h2 id="使用Webpack引入UI依赖">使用Webpack引入UI依赖</h2><p>用<a href="http://webpack.github.io/" target="_blank" rel="external">Webpack</a>处理模块就像在耍瑞士军刀一样，<a href="http://webpack.github.io/docs/motivation.html" target="_blank" rel="external">一切</a>都是为了让你在编写UI模块的时候能够更加精准的引入依赖。</p>
<p>或许你曾使用过<a href="http://dailyjs.com/2010/10/18/modules/" target="_blank" rel="external">CommonJS规范</a>编写过模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#34;underscore&#34;);&#10;&#10;var findTastiestPizza = function (pizzas) &#123;&#10;  return _.find(pizzas, function (pizza) &#123;&#10;    return pizza === &#34;hawaiian&#34;;&#10;  &#125;);&#10;&#125;;&#10;&#10;module.exports = findTastiestPizza;</span><br></pre></td></tr></table></figure>
<p>在NodeJS中用CommonJS依赖加载不是什么稀奇事，但是到了浏览器端，因为网络请求是异步的，所以比较麻烦，需要借助SeaJS、requireJS。</p>
<p>为了让我们的模块能跑在浏览器上，我们得使用Webpack或<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>来将我们页面的所有依赖都打包成单个文件。</p>
<p>可是UI组件不仅仅包含JS，还有CSS、图片甚至字体，<a href="http://webpack.github.io/docs/motivation.html#why-only-javascript" target="_blank" rel="external">Webpack认识到了这点</a>，得益于它的<a href="http://webpack.github.io/docs/using-loaders.html" target="_blank" rel="external">loader机制</a>，使<code>require</code>语法强大到能够精准的引用你需要的任何依赖，而不仅仅是一个单纯的JS文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"stylesheets/modules/btn"</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">require</span>(<span class="string">"images/default_avatar.png"</span>);</span><br></pre></td></tr></table></figure>
<p>嗯，让我们回到我们最初的问题，如何使用程序程序更加智能的生成<code>bundle.css</code>，一个基于HTML真正使用到的CSS，脱离之前手工维护列表的苦海。</p>
<p>所有你需要的做的就是在在所有模板视图声明你的CSS和SASS依赖，和声明JS依赖一样，Webpack将生成最终你需要的所有内容，当然，如果需要，还可以对内容进行预先处理或后置加工。</p>
<p>举个栗子，为我们的应用声明一个加载点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">"react"</span>);</span><br><span class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">"./header"</span>);</span><br><span class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">"./footer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Page = React.createClass(&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Header</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Footer</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="title">Page</span> /&gt;</span>, document.querySelector("#main"));</span></span><br></pre></td></tr></table></figure>
<p>…而那些引入的子模块，它们自身声明了自己所需的SASS依赖…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.js</span></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">"react"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"stylesheets/modules/header"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Header = React.createClass(&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"header"</span>&gt;</span></span><br><span class="line">        Header</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Header;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// footer.js</span></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">"react"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"stylesheets/modules/footer"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"stylesheets/utilities/clearfix"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Footer = React.createClass(&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"footer u-clearfix"</span>&gt;</span></span><br><span class="line">        Footer</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Footer;</span><br></pre></td></tr></table></figure>
<p>…Webpack 最终将生成的像下面这样的CSS文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.header</span> <span class="rules">&#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="class">.footer</span> <span class="rules">&#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="class">.u-clearfix</span> <span class="rules">&#123; <span class="comment">/* ... */</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>你看，是不是很神奇！</p>
<h2 id="其它的一些秘密">其它的一些秘密</h2><h3 id="不再依赖代码书写顺序">不再依赖代码书写顺序</h3><p>值得注意的是，使用这种方式你将无法像手动模式那样组织代码顺序，Webpack将以你指定的<code>require</code>顺序生成代码，就像叠叠乐一样。</p>
<p>所以当我们改变 <code>header</code>和<code>footer</code> 模块的依赖顺序…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">"footer"</span>);</span><br><span class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">"header"</span>);</span><br></pre></td></tr></table></figure>
<p>footer 模块的依赖的样式内容，以及footer中包含的.u-clearfix样式（clearfix），将首先生成出来：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.footer</span> <span class="rules">&#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="class">.u-clearfix</span> <span class="rules">&#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="class">.header</span> <span class="rules">&#123; <span class="comment">/* ... */</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>通常我们在手工维护一个CSS依赖列表时候会根据不同功能类型来进行特定排序，如：</p>
<ul>
<li>base</li>
<li>modules</li>
<li>utilities</li>
</ul>
<p>这些顺序确保了样式间的相互覆写正常。</p>
<p>现在，你无法继续依赖手工排序了，所以你必须更加谨慎的书写你的样式。</p>
<p>我就从来都不喜欢被代码顺序牵着走，我通常会避免在不同的文件中声明相同一个HTML元素的样式，但是有些特殊情况会出现在几个class中都声明了相同的样式属性，不得已的时候你可能会写成这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"footer u-clearfix"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中你需要对这些选择器的处理非常小心才行，SUIT <a href="https://github.com/suitcss/utils#usage" target="_blank" rel="external">推荐使用 !important</a> 来处理这种情况，或者你可以试试这种<a href="http://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/#safely-increasing-specificity" target="_blank" rel="external">多重指定class的HACK方式</a>来提高优先级。</p>
<h3 id="关于SASS全局声明">关于SASS全局声明</h3><p>如果你使用SASS的<code>@import</code>处理你的样式，你可能还需要在各个模块共享你的变量和mixin声明，那么你可能会写过这样的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="string">"config/variables"</span></span><br><span class="line">@import <span class="string">"mixins/vertical_align"</span></span><br><span class="line"></span><br><span class="line">@import <span class="string">"modules/header"</span></span><br><span class="line">@import <span class="string">"modules/footer"</span></span></span><br></pre></td></tr></table></figure>
<p>这样一来跟随在后面的模块都可以共享到config和mixins的内容。</p>
<p>在Webpack的世界里，每一个sass文件都是隔离编译的，<a href="http://blog.teamtreehouse.com/tale-front-end-sanity-beware-sass-import" target="_blank" rel="external">这不无道理</a>，但我觉得有个好的办法来处理这种事情，那就是在你需要引入变量和mixins的地方手动引入它们：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// header.sass</span><br><span class="line">@import "config/colors"</span><br><span class="line"></span><br><span class="line">.header</span><br><span class="line">  color: $red</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// footer.sass</span><br><span class="line">@import "config/colors"</span><br><span class="line"></span><br><span class="line">.footer</span><br><span class="line">  color: $blue</span><br></pre></td></tr></table></figure>
<p>各文件明确指定了自己要的依赖，在我看来，非常轻巧，非常棒！</p>
<h2 id="最最有价值的留在最后">最最有价值的留在最后</h2><p>我在Github上创建了一个<a href="https://github.com/bensmithett/webpack-css-example" target="_blank" rel="external">例子</a>供大家把玩，当然别忘了Star一下我 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在应该没人会把所有样式都写入一个超大的CSS里面了吧…</p>
<blockquote>
<p>原文：<a href="http://bensmithett.com/smarter-css-builds-with-webpack/">Smarter CSS builds with Webpack</a></p>
</blockquote>]]>
    
    </summary>
    
      <category term="CSS，预编译，翻译" scheme="http://blog.xunuo.com/tags/CSS%EF%BC%8C%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%8C%E7%BF%BB%E8%AF%91/"/>
    
      <category term="webpack" scheme="http://blog.xunuo.com/tags/webpack/"/>
    
      <category term="开发者工具" scheme="http://blog.xunuo.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一只不会动的大象 - 如何把你的印象笔记变成本地版。]]></title>
    <link href="http://blog.xunuo.com/local-your-evernote/"/>
    <id>http://blog.xunuo.com/local-your-evernote/</id>
    <published>2015-06-15T16:37:55.000Z</published>
    <updated>2015-06-15T16:37:55.000Z</updated>
    <content type="html"><![CDATA[<img src="/local-your-evernote/3.jpg" alt="3.jpg" title="">
<p>印象笔记(evernote)算是我用得最顺手的一款笔记软件了，但有些时候总担心一些敏感信息同步到云端会导致安全问题，那么问题来了…</p>
<a id="more"></a>
<hr>
<p>不知不觉，我在印象笔记里面已经记了快3000条笔记了，得益于它强大的图片文本搜索、舒服的粘贴体验和方便的提醒功能，特别适合用来收集大量碎片资源，咳咳，我只是一个喜欢大象的粉丝，这篇不是软文…</p>
<p>因为记录太方便，难免有一些时候会偷懒记录一些敏感信息进去，比如密码什么的，万一哪天同步笔记时候被劫持… 呃，你看，又是一出悲剧是吧。</p>
<p>不过还好它提供了“本地笔记本”功能，这样一来就能一边继续享用它强大的功能，同时又规避掉安全问题。</p>
<p>那么接下来，以MAC下的Evernote国际版(v6.0.8)为例，简单的介绍一下用法，windows的同学设置应该也差不多。</p>
<h3 id="首先，安全第一">首先，安全第一</h3><blockquote>
<p>如果感觉有信息泄露的风险，那么我们还是暂时先关闭掉印象笔记的自动同步功能，等整理好之后再开放，安全第一 :)</p>
</blockquote>
<p>打开印象笔记主菜单 » 偏好设置 » “同步”选项卡，如下图所示设置。</p>
<p><img src="5.png" alt="关闭印象笔记同步功能"></p>
<h3 id="如何建立「本地笔记本」">如何建立「本地笔记本」</h3><p>打开印象笔记主菜单 » 文件 » 新建笔记本 » 本地笔记本。<br><img src="4.png" alt="建立印象笔记本地笔记本"></p>
<p>然后，起个名字吧 :)</p>
<p><img src="6.png" alt="建立印象笔记本地笔记本2"> </p>
<h3 id="新建一则本地笔记">新建一则本地笔记</h3><p>建立笔记和往常一样，在本地笔记本下新建笔记即可</p>
<p><img src="7.png" alt="建立印象笔记本地笔记"></p>
<p>这时候你会发现“同步”功能是没有作用的 :) </p>
<h3 id="转移「同步笔记本」内的笔记到「本地笔记本」">转移「同步笔记本」内的笔记到「本地笔记本」</h3><p>选取不需要同步的笔记，直接拖拽至新建的「本地笔记本」即可。</p>
<blockquote>
<p>注意：转移笔记是需要时间的，移动笔记后虽然「同步笔记本」中笔记计数变为零，但是如果转移笔记较多，此时转移操作依旧在后台进行，请耐心等候，不要心急关闭应用。</p>
</blockquote>
<h3 id="恢复同步功能">恢复同步功能</h3><p>别忘了，按照第一步将同步选项卡下的设置还原。</p>
<p>在一次同步之后，再到其它印象笔记终端观察数据，如若正常，是看不到刚才新建的「本地笔记本」，同时尝试找找那些被转移的笔记，是不是也消失得无影无踪了 :)</p>
<blockquote>
<p>注意: 如果只是需要把印象笔记彻底当本地版使用，你也可以依旧保持手动同步，但是转移数据之后切记需要至少同步一次。</p>
</blockquote>
<h3 id="更高级的用法">更高级的用法</h3><p>如果你需要备份数据或有信得过的云存储产品，比如公司自己使用的云盘，也可以通过软链接的方式将印象笔记的存储文件夹映射到云盘的一个文件夹，通过这种桥接方式重新获得印象笔记的多终端共享功能。</p>
<p>MAC下印象笔记的本地存储路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Application Support/com.evernote.Evernote</span><br></pre></td></tr></table></figure></p>
<p>如果你的云盘目录是 <code>~/CloudDrive/</code>，那么可以通过如下语句进行映射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ~/Library/Application\ Support/com.evernote.Evernote ~/CloudDrive/evernote</span><br></pre></td></tr></table></figure></p>
<p>接着，在其它的设备上也如此设置即可。</p>
<blockquote>
<p>注意：命令中的空格需要使用“\”转义，如 <code>Application\ Support</code></p>
</blockquote>
<hr>
<p>OK，恭喜你，现在你终于有了一头“不能动”的大象，再也不会走私你的数据啦 :) </p>
<p><img src="2.jpg" alt="不能动的evernote"></p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/local-your-evernote/3.jpg" alt="3.jpg" title="">
<p>印象笔记(evernote)算是我用得最顺手的一款笔记软件了，但有些时候总担心一些敏感信息同步到云端会导致安全问题，那么问题来了…</p>]]>
    
    </summary>
    
      <category term="evernote" scheme="http://blog.xunuo.com/tags/evernote/"/>
    
      <category term="印象笔记" scheme="http://blog.xunuo.com/tags/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0/"/>
    
      <category term="技巧" scheme="http://blog.xunuo.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="http://blog.xunuo.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>